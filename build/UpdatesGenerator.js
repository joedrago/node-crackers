// Generated by CoffeeScript 1.9.3
(function() {
  var BUCKET_WINDOW, UpdatesGenerator, cfs, constants, formatDate, formatPrettyDate, moment, path, sortByRelativeDir, sortByTimestampDescending;

  cfs = require('./cfs');

  constants = require('./constants');

  moment = require('moment');

  path = require('path');

  BUCKET_WINDOW = 24 * 60 * 60;

  formatDate = function(ts) {
    return moment(ts * 1000).format('YYYYMMDD');
  };

  formatPrettyDate = function(ts) {
    return moment(ts * 1000).format('MMMM Do, YYYY');
  };

  sortByRelativeDir = function(a, b) {
    if (a.relativeDir < b.relativeDir) {
      return -1;
    }
    if (a.relativeDir > b.relativeDir) {
      return 1;
    }
    return 0;
  };

  sortByTimestampDescending = function(a, b) {
    if (a.timestamp < b.timestamp) {
      return 1;
    }
    if (a.timestamp > b.timestamp) {
      return -1;
    }
    return 0;
  };

  UpdatesGenerator = (function() {
    function UpdatesGenerator(rootDir) {
      var action, bucket, comic, dir, endIssue, i, issue, j, k, len, len1, len2, parsed, ref, ref1, seriesCover, seriesDir, startDir, startIssue, timeBuckets, ts, update;
      this.rootDir = rootDir;
      this.comics = cfs.gatherComics(this.rootDir);
      this.comics.sort(sortByTimestampDescending);
      timeBuckets = [];
      bucket = null;
      ref = this.comics;
      for (i = 0, len = ref.length; i < len; i++) {
        comic = ref[i];
        ts = this.roundTimestamp(comic.timestamp);
        if (bucket) {
          if (bucket.start === ts) {
            bucket.list.push(comic);
          } else {
            bucket = null;
          }
        }
        if (!bucket) {
          bucket = {
            start: ts,
            list: [comic]
          };
          timeBuckets.push(bucket);
        }
      }
      this.updates = [];
      for (j = 0, len1 = timeBuckets.length; j < len1; j++) {
        bucket = timeBuckets[j];
        update = {
          list: [],
          pdate: formatPrettyDate(bucket.start),
          date: formatDate(bucket.start)
        };
        this.updates.push(update);
        bucket.list.sort(sortByRelativeDir);
        seriesCover = null;
        seriesDir = null;
        startDir = null;
        startIssue = 0;
        endIssue = 0;
        ref1 = bucket.list;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          comic = ref1[k];
          parsed = path.parse(comic.relativeDir);
          issue = parseInt(parsed.name);
          if ((issue === NaN) || (startDir !== parsed.dir) || (issue !== endIssue + 1)) {
            if (startDir && (startIssue > 0) && (endIssue > 0)) {
              dir = startDir;
              action = 'browse';
              if (startIssue === endIssue) {
                dir = seriesDir;
                action = 'comic';
              }
              update.list.push({
                action: action,
                dir: dir,
                title: startDir,
                start: startIssue,
                end: endIssue,
                cover: seriesCover
              });
              startDir = null;
              seriesCover = null;
            }
            if (issue > 0) {
              startDir = parsed.dir;
              startIssue = endIssue = issue;
              seriesCover = comic.relativeDir + "/" + constants.COVER_FILENAME;
              seriesDir = comic.relativeDir;
            } else {
              update.list.push({
                action: 'comic',
                dir: comic.relativeDir,
                title: comic.relativeDir,
                cover: comic.relativeDir + "/" + constants.COVER_FILENAME
              });
            }
          } else {
            endIssue = issue;
          }
        }
        if (startDir && (startIssue > 0) && (endIssue > 0)) {
          dir = startDir;
          action = 'browse';
          if (startIssue === endIssue) {
            dir = seriesDir;
            action = 'comic';
          }
          update.list.push({
            action: action,
            dir: dir,
            title: startDir,
            start: startIssue,
            end: endIssue,
            cover: seriesCover
          });
        }
      }
    }

    UpdatesGenerator.prototype.roundTimestamp = function(ts) {
      return Math.round(ts / BUCKET_WINDOW) * BUCKET_WINDOW;
    };

    UpdatesGenerator.prototype.getUpdates = function() {
      return this.updates;
    };

    return UpdatesGenerator;

  })();

  module.exports = UpdatesGenerator;

}).call(this);
