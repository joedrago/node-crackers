// Generated by CoffeeScript 1.9.3
(function() {
  var Unpacker, cfs, constants, exec, fs, log, path, which;

  fs = require('fs');

  cfs = require('./cfs');

  constants = require('./constants');

  exec = require('./exec');

  log = require('./log');

  path = require('path');

  which = require('which');

  Unpacker = (function() {
    function Unpacker(archive, dir) {
      var now;
      this.archive = archive;
      this.dir = dir;
      this.detectFormat();
      now = String(Math.floor(new Date() / 1000));
      this.tempDir = cfs.join(this.dir, constants.TEMP_UNPACK_DIR + "." + now);
      this.imagesDir = cfs.join(this.dir, constants.IMAGES_DIR);
      this.deadImagesDir = this.imagesDir + "." + now;
      this.valid = false;
    }

    Unpacker.prototype.cleanup = function() {
      cfs.cleanupDir(this.tempDir);
      cfs.cleanupDir(this.deadImagesDir);
      if (!this.valid) {
        return cfs.cleanupDir(this.imagesDir);
      }
    };

    Unpacker.prototype.readHeader = function() {
      var buffer, bytesRead, fd;
      fd = fs.openSync(this.archive, 'r');
      buffer = new Buffer(2);
      bytesRead = fs.readSync(fd, buffer, 0, 2, 0);
      if (bytesRead === 2) {
        return buffer.toString();
      }
      return false;
    };

    Unpacker.prototype.detectFormat = function() {
      var header;
      this.type = 'cbr';
      if (this.archive.match(/cbz$/)) {
        this.type = 'cbz';
      }
      header = this.readHeader();
      if (header) {
        switch (header) {
          case 'Ra':
            this.type = 'cbr';
            break;
          case 'PK':
            this.type = 'cbz';
        }
      }
      return log.verbose("Detected format for " + this.archive + ": " + this.type);
    };

    Unpacker.prototype.unpack = function() {
      var args, cmd, finalImagePath, i, image, images, len, parsed;
      log.verbose("Unpacker: type " + this.type + " " + this.archive + " -> " + this.dir);
      log.verbose("Unpacker: @tempDir " + this.tempDir);
      if (!cfs.prepareDir(this.tempDir)) {
        log.error("Could not create temp dir for unpacking");
        return false;
      }
      if (this.type === 'cbr') {
        cmd = 'unrar';
        args = ['x', this.archive];
      } else {
        cmd = 'unzip';
        args = [this.archive];
      }
      exec(cmd, args, this.tempDir);
      if (fs.existsSync(this.imagesDir)) {
        log.verbose("moving old images dir " + this.imagesDir + " to " + this.deadImagesDir);
        fs.renameSync(this.imagesDir, this.deadImagesDir);
      }
      if (!cfs.prepareDir(this.imagesDir)) {
        log.error("Could not create images dir");
        return false;
      }
      images = cfs.listImages(this.tempDir);
      if (!images.length) {
        return false;
      }
      for (i = 0, len = images.length; i < len; i++) {
        image = images[i];
        parsed = path.parse(image);
        finalImagePath = cfs.join(this.imagesDir, parsed.base);
        fs.renameSync(image, finalImagePath);
      }
      this.valid = true;
      return true;
    };

    return Unpacker;

  })();

  module.exports = Unpacker;

}).call(this);
