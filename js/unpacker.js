// Generated by CoffeeScript 1.9.3
(function() {
  var Unpacker, cfs, constants, fs, log, path, spawnSync, which;

  fs = require('fs');

  cfs = require('./cfs');

  constants = require('./constants');

  log = require('./log');

  path = require('path');

  spawnSync = require('child_process').spawnSync;

  which = require('which');

  Unpacker = (function() {
    function Unpacker(archive, dir) {
      var now;
      this.archive = archive;
      this.dir = dir;
      this.type = 'cbr';
      if (this.archive.match(/cbz$/)) {
        this.type = 'cbz';
      }
      this.unzipCmd = null;
      this.unrarCmd = null;
      if (process.platform === 'win32') {
        this.unzipCmd = path.resolve(__dirname, "../wbin/unzip.exe");
        this.unrarCmd = path.resolve(__dirname, "../wbin/unrar.exe");
      } else {
        try {
          this.unzipCmd = which.sync('unzip');
        } catch (_error) {

        }
        try {
          this.unrarCmd = which.sync('unrar');
        } catch (_error) {

        }
      }
      if (!this.unzipCmd) {
        log.error("crackers requires unzip to be installed.");
      }
      if (!this.unrarCmd) {
        log.error("crackers requires unrar to be installed.");
      }
      log.verbose("unzip: " + this.unzipCmd);
      log.verbose("unrar: " + this.unrarCmd);
      now = String(Math.floor(new Date() / 1000));
      this.tempDir = cfs.join(this.dir, constants.TEMP_UNPACK_DIR + "." + now);
      this.imagesDir = cfs.join(this.dir, constants.IMAGES_DIR);
      this.deadImagesDir = this.imagesDir + "." + now;
      this.valid = false;
    }

    Unpacker.prototype.cleanup = function() {
      cfs.cleanupDir(this.tempDir);
      cfs.cleanupDir(this.deadImagesDir);
      if (!this.valid) {
        return cfs.cleanupDir(this.imagesDir);
      }
    };

    Unpacker.prototype.unpack = function() {
      var args, cmd, finalImagePath, i, image, images, len, parsed;
      if (!this.unzipCmd || !this.unrarCmd) {
        return false;
      }
      log.verbose("Unpacker: Type " + this.type + " " + this.archive + " -> " + this.dir);
      log.verbose("Unpacker: @tempDir " + this.tempDir);
      if (!cfs.prepareDir(this.tempDir)) {
        log.error("Could not create temp dir for unpacking");
        return false;
      }
      if (this.type === 'cbr') {
        cmd = this.unrarCmd;
        args = ['x', this.archive];
      } else {
        cmd = this.unzipCmd;
        args = [this.archive];
      }
      log.verbose("Unpacker: executing cmd '" + cmd + "', args " + args);
      spawnSync(cmd, args, {
        cwd: this.tempDir,
        stdio: 'ignore'
      });
      if (fs.existsSync(this.imagesDir)) {
        log.verbose("moving old images dir " + this.imagesDir + " to " + this.deadImagesDir);
        fs.renameSync(this.imagesDir, this.deadImagesDir);
      }
      if (!cfs.prepareDir(this.imagesDir)) {
        log.error("Could not create images dir");
        return false;
      }
      images = cfs.listImages(this.tempDir);
      if (!images.length) {
        return false;
      }
      for (i = 0, len = images.length; i < len; i++) {
        image = images[i];
        parsed = path.parse(image);
        finalImagePath = cfs.join(this.imagesDir, parsed.base);
        fs.renameSync(image, finalImagePath);
      }
      this.valid = true;
      return true;
    };

    return Unpacker;

  })();

  module.exports = Unpacker;

}).call(this);
