// Generated by CoffeeScript 1.9.3
(function() {
  var cfs, constants, fs, log, path, wrench;

  constants = require('./constants');

  fs = require('fs');

  path = require('path');

  log = require('./log');

  wrench = require('wrench');

  cfs = {};

  cfs.join = function() {
    var result;
    result = path.join.apply(null, arguments);
    if (arguments.length > 0 && arguments[0] === '') {
      result = "/" + result;
    }
    return result;
  };

  cfs.dirExists = function(dir) {
    var stats;
    if (!fs.existsSync(dir)) {
      return false;
    }
    stats = fs.statSync(dir);
    if (stats.isDirectory()) {
      return true;
    }
    return false;
  };

  cfs.dirTime = function(dir) {
    var dirStats;
    dirStats = fs.statSync(dir);
    if (dirStats == null) {
      return 0;
    }
    return Math.floor(dirStats.birthtime.getTime() / 1000);
  };

  cfs.fileExists = function(file) {
    var stats;
    if (!fs.existsSync(file)) {
      return false;
    }
    stats = fs.statSync(file);
    if (stats.isFile()) {
      return true;
    }
    return false;
  };

  cfs.fileHasBytes = function(file) {
    var stats;
    if (!fs.existsSync(file)) {
      return false;
    }
    stats = fs.statSync(file);
    if (stats.isFile()) {
      return stats.size > 0;
    }
    return false;
  };

  cfs.findArchive = function(dir, comic) {
    var basename;
    basename = path.join(dir, comic);
    if (cfs.fileExists(basename + ".cbr")) {
      return comic + ".cbr";
    }
    if (cfs.fileExists(basename + ".cbt")) {
      return comic + ".cbt";
    }
    if (cfs.fileExists(basename + ".cbz")) {
      return comic + ".cbz";
    }
    return false;
  };

  cfs.findParentContainingFilename = function(startDir, filename) {
    var dirPieces, found, testPath, testPieces;
    startDir = path.resolve('.', startDir);
    dirPieces = startDir.split(path.sep);
    while (true) {
      if (!dirPieces.length) {
        return false;
      }
      testPieces = dirPieces.slice();
      testPieces.push(filename);
      testPath = cfs.join.apply(null, testPieces);
      found = cfs.fileExists(testPath);
      if (found) {
        return cfs.join.apply(null, dirPieces);
      }
      dirPieces.pop();
    }
    return false;
  };

  cfs.listDir = function(dir) {
    return wrench.readdirSyncRecursive(dir);
  };

  cfs.listImages = function(dir) {
    var file, images, list;
    list = wrench.readdirSyncRecursive(dir);
    images = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        file = list[i];
        if (file.match(/\.(png|jpg|jpeg|webp)$/i)) {
          results.push(path.resolve(dir, file));
        }
      }
      return results;
    })();
    return images.sort();
  };

  cfs.gatherComics = function(rootDir) {
    var comicDirs, comics, dir, file, i, len, list, metadata, relativeDir;
    rootDir = rootDir.replace(path.sep + "$", "");
    list = wrench.readdirSyncRecursive(rootDir);
    comicDirs = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        file = list[i];
        if (file.match(/images$/i)) {
          results.push(path.resolve(rootDir, file).replace(/\/images$/, ""));
        }
      }
      return results;
    })();
    comics = [];
    for (i = 0, len = comicDirs.length; i < len; i++) {
      dir = comicDirs[i];
      relativeDir = dir.substr(rootDir.length + 1);
      metadata = cfs.readMetadata(dir);
      if (metadata) {
        metadata.dir = dir;
        metadata.relativeDir = relativeDir;
        comics.push(metadata);
      }
    }
    return comics;
  };

  cfs.gatherMetadata = function(dir) {
    var file, fileList, i, len, mdList, metadata, resolvedPath;
    mdList = [];
    fileList = fs.readdirSync(dir).sort();
    for (i = 0, len = fileList.length; i < len; i++) {
      file = fileList[i];
      resolvedPath = path.resolve(dir, file);
      metadata = cfs.readMetadata(resolvedPath);
      if (!metadata) {
        continue;
      }
      metadata.path = file;
      mdList.push(metadata);
    }
    mdList.sort(function(a, b) {
      if (a.path === b.path) {
        return 0;
      }
      if (a.path > b.path) {
        return 1;
      }
      return -1;
    });
    return mdList;
  };

  cfs.readMetadata = function(dir) {
    var metaFilename, metadata, rawText;
    metaFilename = cfs.join(dir, constants.META_FILENAME);
    if (!fs.existsSync(metaFilename)) {
      return false;
    }
    rawText = fs.readFileSync(metaFilename);
    if (!rawText) {
      return false;
    }
    try {
      metadata = JSON.parse(rawText);
    } catch (_error) {
      metadata = false;
    }
    return metadata;
  };

  cfs.touchRoot = function(dir) {
    var json, rootFilename, rootinfo;
    rootFilename = cfs.join(dir, constants.ROOT_FILENAME);
    if (cfs.fileHasBytes(rootFilename)) {
      return;
    }
    rootinfo = {
      title: constants.DEFAULT_TITLE
    };
    json = JSON.stringify(rootinfo, null, 2);
    return fs.writeFileSync(rootFilename, json);
  };

  cfs.getRootTitle = function(dir) {
    var data, rawJSON, rootFilename;
    rootFilename = cfs.join(dir, constants.ROOT_FILENAME);
    if (cfs.fileHasBytes(rootFilename)) {
      try {
        rawJSON = fs.readFileSync(rootFilename);
        data = JSON.parse(rawJSON);
        if (data.title) {
          return data.title;
        }
      } catch (_error) {

      }
    }
    return constants.DEFAULT_TITLE;
  };

  cfs.writeMetadata = function(dir, metadata) {
    var json, metaFilename;
    metaFilename = cfs.join(dir, constants.META_FILENAME);
    json = JSON.stringify(metadata, null, 2);
    return fs.writeFileSync(metaFilename, json);
  };

  cfs.removeMetadata = function(dir, metadata) {
    var metaFilename;
    metaFilename = cfs.join(dir, constants.META_FILENAME);
    return fs.unlinkSync(metaFilename);
  };

  cfs.copyFile = function(src, dst) {
    log.verbose("copyFile " + src + " -> " + dst);
    return fs.writeFileSync(dst, fs.readFileSync(src));
  };

  cfs.prepareDir = function(dir) {
    var stats;
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
    }
    if (!fs.existsSync(dir)) {
      log.error("Cannot create directory " + dir + ", mkdir failed");
      return false;
    }
    stats = fs.statSync(dir);
    if (!stats.isDirectory()) {
      log.error("Cannot create directory " + dir + ", file exists (not a dir)");
      return false;
    }
    return true;
  };

  cfs.prepareComicDir = function(dir) {
    if (!cfs.prepareDir(dir)) {
      return false;
    }
    log.verbose("Comic directory prepared: " + dir);
    return true;
  };

  cfs.cleanupDir = function(dir) {
    if (fs.existsSync(dir)) {
      log.verbose("Cleaning up " + dir);
      wrench.rmdirSyncRecursive(dir, true);
    }
  };

  cfs.newer = function(amINewer, thanThisFile) {
    var amINewerStats, thanThisFileStats;
    if (!fs.existsSync(amINewer)) {
      return true;
    }
    if (!fs.existsSync(thanThisFile)) {
      return true;
    }
    amINewerStats = fs.statSync(amINewer);
    thanThisFileStats = fs.statSync(thanThisFile);
    return amINewerStats.mtime > thanThisFileStats.mtime;
  };

  module.exports = cfs;

}).call(this);
