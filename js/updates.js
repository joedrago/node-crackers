// Generated by CoffeeScript 1.9.3
(function() {
  var BUCKET_WINDOW, Updates, cfs, formatTimestamp, fs, moment, path, sortByRelativeDir, sortByTimestampDescending;

  cfs = require('./cfs');

  fs = require('fs');

  moment = require('moment');

  path = require('path');

  BUCKET_WINDOW = 24 * 60 * 60;

  formatTimestamp = function(ts) {
    return moment(ts * 1000).format('MMMM Do, YYYY');
  };

  sortByRelativeDir = function(a, b) {
    if (a.relativeDir < b.relativeDir) {
      return -1;
    }
    if (a.relativeDir > b.relativeDir) {
      return 1;
    }
    return 0;
  };

  sortByTimestampDescending = function(a, b) {
    if (a.timestamp < b.timestamp) {
      return 1;
    }
    if (a.timestamp > b.timestamp) {
      return -1;
    }
    return 0;
  };

  Updates = (function() {
    function Updates(rootDir) {
      var bucket, comic, endIssue, i, issue, j, k, len, len1, len2, parsed, ref, ref1, startDir, startIssue, timeBuckets, ts, update;
      this.rootDir = rootDir;
      this.comics = cfs.gatherComics(this.rootDir);
      this.comics.sort(sortByTimestampDescending);
      timeBuckets = [];
      bucket = null;
      ref = this.comics;
      for (i = 0, len = ref.length; i < len; i++) {
        comic = ref[i];
        ts = this.roundTimestamp(comic.timestamp);
        if (bucket) {
          if (bucket.start === ts) {
            bucket.list.push(comic);
          } else {
            bucket = null;
          }
        }
        if (!bucket) {
          bucket = {
            start: ts,
            list: [comic]
          };
          timeBuckets.push(bucket);
        }
      }
      this.updates = [];
      for (j = 0, len1 = timeBuckets.length; j < len1; j++) {
        bucket = timeBuckets[j];
        update = {
          list: [],
          date: formatTimestamp(bucket.start)
        };
        this.updates.push(update);
        bucket.list.sort(sortByRelativeDir);
        startDir = null;
        startIssue = 0;
        endIssue = 0;
        ref1 = bucket.list;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          comic = ref1[k];
          parsed = path.parse(comic.relativeDir);
          issue = parseInt(parsed.name);
          if ((issue === NaN) || (startDir !== parsed.dir) || (issue !== endIssue + 1)) {
            if (startDir && (startIssue > 0) && (endIssue > 0)) {
              update.list.push({
                dir: startDir,
                start: startIssue,
                end: endIssue
              });
              startDir = null;
            }
            if (issue > 0) {
              startDir = parsed.dir;
              startIssue = endIssue = issue;
            } else {
              update.list.push({
                dir: comic.relativeDir
              });
            }
          } else {
            endIssue = issue;
          }
        }
        if (startDir && (startIssue > 0) && (endIssue > 0)) {
          update.list.push({
            dir: startDir,
            start: startIssue,
            end: endIssue
          });
        }
      }
    }

    Updates.prototype.roundTimestamp = function(ts) {
      return Math.round(ts / BUCKET_WINDOW) * BUCKET_WINDOW;
    };

    Updates.prototype.getUpdates = function() {
      return this.updates;
    };

    return Updates;

  })();

  module.exports = Updates;

}).call(this);
